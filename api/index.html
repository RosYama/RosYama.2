<!DOCTYPE html>
<html>
<head>
    <title>API РосЯмы</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	<style>
		pre { margin-left: 30px; }
		.comment { font-size: small; }
		table { border-left: 1px solid grey; border-top: 1px solid grey; }
		td, th { padding: 4px; border-right: 1px solid grey; border-bottom: 1px solid grey; }
	</style>
</head>
<body>
	<h1>API РосЯмы</h1>
	<p class="comment">Соответствует текущей версии 2.0Beta РосЯмы.</p>
	<p>Общение с сервером РосЯмы любое внешнее приложение осуществляет посредством запроса к серверу по протоколу http (а лучше — https, но сейчас это ещё не реализовано) на определённый адрес. Сервер в ответ присылает XML.</p>
	<p>Запросы могут быть посланы как методом GET, так и методом POST, в зависимости от запроса. В случае, если приложение отправляет запрос методом GET, то может передать какие-нибудь данные в строке URL, а также в строке URL содержится тип запроса. Проще говоря, в зависимости от того, что приложение хочет получить и сообщить, оно формирует запрос на определённый URL. Запросы методом POST используются для отправки на сервер больших объёмов информации (загрузка картинок и так далее), а также могут быть использованы для выполнения запросов, которые требуют авторизации. Все запросы, для которых авторизация не требуется, отправляются на сервер методом GET.</p>
	<p>Промышленный сервер, который принимает запросы: <a href="http://xml.rosyama.ru/">xml.rosyama.ru</a>.</p>
	<p>Тестовый сервер, на котором можно отлаживать приложения: <a href="http://xml_st1234.greensight.ru">xml_st1234.greensight.ru</a> или <a href="xml-st1234.greensight.ru/">xml-st1234.greensight.ru</a>. Веб-интерфейс тестового сервера: <a href="http://st1234.greensight.ru/">st1234.greensight.ru</a>.
	<p>Следует помнить, что тестовый сервер обычно имеет более свежую версию исходного кода и может работать (что обычно и происходит) менее стабильно, чем промышленный, так как изменения происходят там в непрерывном режиме, а на промышленный сервер переносятся пачками время от времени. Текущая версия API на промышленном сервере описана по адресу <a href="http://rosyama.ru/api/">rosyama.ru/api</a>, на тестовом сервере по адресу <a href="http://st1234.greensight.ru/api/">st1234.greensight.ru/api</a>.</p>

	<h2>Формат XML ответа сервера</h2>
	<p>Валидный ответ сервера выглядит следующим образом:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;st1234reply&gt;
	&lt;requesttime&gt; тут время запроса (таймстамп) &lt;/requesttime&gt;
	&lt;requestmethod&gt; тут метод запроса (обычно GET или POST) &lt;/requestmethod&gt;
	&lt;replytime&gt; тут время ответа сервера (таймстамп) &lt;/replytime&gt;
	
	Тело ответа.
	
&lt;/st1234reply&gt;</pre>
	<p>Сервер принимает запросы и выдаёт ответы в кодировке UTF-8. Использование иной кодировки в запросе не запрещается, но и не гарантирует адекватные ответы.</p>
	
	<h2>Формат XML ошибок</h2>
	<p>В случае каких-либо проблем или ошибок, которые сервер может обработать, он отвечает XML с описанием ошибки. XML ошибки содержит внутри ответа элемент &lt;error/&gt;, у которого есть свойство code, а в себе он содержит текст ошибки. Например:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;st1234reply&gt;
	&lt;requesttime&gt;1307535706&lt;/requesttime&gt;
	&lt;requestmethod&gt;GET&lt;/requestmethod&gt;
	&lt;replytime&gt;1307535707&lt;/replytime&gt;
	&lt;error code="NOT_IMPLEMENTED"&gt;Метод не реализован&lt;/error&gt;
&lt;/st1234reply&gt;</pre>
	<p>Ниже представлен перечень кодов ошибок, которые сервер может возвращать:</p>
	<table cellspacing="0">
		<tr>
			<td>NOT_IMPLEMENTED</td>
			<td>Метод не реализован</td>
		</tr>
		<tr>
			<td>NOT_FOUND</td>
			<td>Запрашиваемый ресурс не найден</td>
		</tr>
		<tr>
			<td>NO_FILES</td>
			<td>Не загружено ни одного файла</td>
		</tr>
		<tr>
			<td>TOO_BIG_FILE</td>
			<td>Слишком большой файл</td>
		</tr>
		<tr>
			<td>TOO_MANY_FILES</td>
			<td>Слишком много файлов</td>
		</tr>
		<tr>
			<td>PARTIALLY_UPLOADED_FILE</td>
			<td>Файл загружен только частично</td>
		</tr>
		<tr>
			<td>CANNOT_UPLOAD_FILE</td>
			<td>Невозможно загрузить файл</td>
		</tr>
		<tr>
			<td>UNKNOWN_MIME_TYPE</td>
			<td>Неподдерживаемый тип файла</td>
		</tr>
		<tr>
			<td>UNKNOWN_IMAGE_FORMAT</td>
			<td>Неподдерживаемый формат изображения</td>
		</tr>
		<tr>
			<td>INCORRECT_TYPE</td>
			<td>Неправильный тип дефекта</td>
		</tr>
		<tr>
			<td>DEPRECATED_TYPE</td>
			<td>Неиспользуемый в данный момент тип дефекта</td>
		</tr>
		<tr>
			<td>CANNOT_ADD_DEFECT</td>
			<td>Невозможно добавить дефект</td>
		</tr>
		<tr>
			<td>AUTHORIZATION_REQUIRED</td>
			<td>Требуется авторизация</td>
		</tr>
		<tr>
			<td>LATITUDE_NOT_SET</td>
			<td>Не указана широта дефекта</td>
		</tr>
		<tr>
			<td>LONGITUDE_NOT_SET</td>
			<td>Не указана долгота дефекта</td>
		</tr>
		<tr>
			<td>NO_ADDRESS</td>
			<td>Не указан адрес</td>
		</tr>
		<tr>
			<td>WRONG_CREDENTIALS</td>
			<td>Неправильный логин и/или пароль</td>
		</tr>
		<tr>
			<td>UNAPPROPRIATE_METHOD</td>
			<td>Неподходящий метод</td>
		</tr>
		<tr>
			<td>CANNOT_UPDATE_DEFECT</td>
			<td>Не удалось обновить дефект</td>
		</tr>
		<tr>
			<td>CANNOT_DELETE_DEFECT</td>
			<td>Не удалось удалить дефект</td>
		</tr>
		<tr>
			<td>GEOCODE_ERROR</td>
			<td>Не удалось произвести геокодирование</td>
		</tr>
		<tr>
			<td>GEOCODE_EMPTY_REQUEST</td>
			<td>Пустой запрос к геокодеру</td>
		</tr>
		<tr>
			<td>INTERNAL</td>
			<td>Иная внутренняя ошибка</td>
		</tr>
	</table>
	
	<h2>Формат предупреждений</h2>
	<p>Помимо ошибок, сервер может возвращать предупреждения. Тэг предупреждения имеет следующий формат:</p>
	<pre>&lt;warning code="WARNING"&gt;Это предупреждение&lt;/warning&gt;</pre>
	<p>Предупреждений может быть несколько, и они могут соседствовать с прочими элементами в ответе сервера. Предупреждения могут быть возвращены в ответах не на все запросы, а только на некоторые, и все возможные случаи описаны отдельно. Обрабатывать предупреждения или нет — дело разработчика приложения.</p>
	<p>Возможные предупреждения, который может возвращать сервер:</p>
	<table cellspacing="0">
		<tr>
			<td>FILES_DROPPED</td>
			<td>Несколько файлов не загружено на сервер</td>
		</tr>
		<tr>
			<td>CANNOT_REALISE_SUBJECTRF</td>
			<td>Не удалось распознать субъект РФ</td>
		</tr>
		<tr>
			<td>CANNOT_REALISE_CITY</td>
			<td>Не удалось распознать город</td>
		</tr>
		<tr>
			<td>FILES_LIMIT_REACHED</td>
			<td>Достигнуто максимальное количество файлов для одного дефекта</td>
		</tr>
		<tr>
			<td>NO_SUBJECTRF_ID</td>
			<td>Дефект не привязан к субъекту РФ</td>
		</tr>
	</table>
	
	<h2>Формат XML описания дефекта</h2>
	<p>В разных запросах могут приходить описания разных дефектов. В списке дефектов их несколько, в карточке дефекта — он, соответственно, один. Во всех случаях XML с описанием дефекта выглядит одинаково.</p>
	<pre>&lt;hole id="номер дефекта"&gt;
	&lt;id&gt; номер дефекта &lt;/id&gt;
	&lt;username full="полоное имя пользователя"&gt;
		&lt;name&gt;имя&lt;/name&gt;
		&lt;secondname&gt;отчество&lt;/secondname&gt;
		&lt;lastname&gt;фамилия&lt;/lastname&gt;
	&lt;/username&gt;
	&lt;latitude&gt; широта &lt;/latitude&gt;
	&lt;longitude&gt; долгота &lt;/longitude&gt;
	&lt;address city="название города" subjectrf="идентификатор субъекта РФ"&gt;полный адрес дефекта&lt;/address&gt;
	&lt;state code="код статуса дефекта"&gt;русское название статуса&lt;/state&gt;
	&lt;type code="код типа дефекта"&gt;русское название типа&lt;/type&gt;
	&lt;datecreated readable="02.06.2011"&gt;1307003591&lt;/datecreated&gt; - дата создания дефекта
	&lt;datesent readable="02.06.2011"&gt;1307003789&lt;/datesent&gt; - дата отправки заявления в ГИБДД
	&lt;datestatus readable="02.06.2011"&gt;1307003797&lt;/datestatus&gt; - дата простановки текущего статуса
	&lt;commentfresh&gt;комментарий пользователя к дефекту&lt;/commentfresh&gt;
	&lt;commentfixed&gt;комментарий, который пользователь оставляет при отметке дефекта, как починенного&lt;/commentfixed&gt;
	&lt;commentgibddre&gt;комментарий, который пользователь оставляет при простановке статуса «пришёл ответ из ГИБДД»&lt;/commentgibddre&gt;
	&lt;pictures&gt;
		&lt;original&gt; - картинки оригинального размера (ну на самом деле не оригинального, я ужатого до 1024 пикселей по ширине для экономии места на сервере)
			&lt;fresh&gt; - картинки к «свежему» дефекту, загружаемые на сайт при добавлении дефекта. Этот элемент (равно как и соседние с ним &lt;gibddreply&gt; и &lt;fixed&gt;) может иметь внутри любое (в том числе и нулевое) количество элементов &lt;src&gt;, в которых содержатся пути к картинкам дефектов относительно корня http-сервера (обычного, где крутится сайт)
				&lt;src id=&quot;123&quot;&gt;src&lt;/src&gt; - путь к каринке и ее ID
				&lt;src id=&quot;124&quot;&gt;src&lt;/src&gt;
				...
			&lt;/fresh&gt;
			&lt;gibddreply&gt;...&lt;/gibddreply&gt;
			&lt;fixed&gt;...&lt;/fixed&gt;
		&lt;/original&gt;
		&lt;medium&gt; - картинки среднего размера, которые показываются на сайте внутри карточки дефекта
			&lt;fresh&gt;...&lt;/fresh&gt;
			&lt;gibddreply&gt;...&lt;/gibddreply&gt;
			&lt;fixed&gt;...&lt;/fixed&gt;
		&lt;/medium&gt;
		&lt;small&gt; - картинки маленького размера
			&lt;fresh&gt;...&lt;/fresh&gt;
			&lt;gibddreply&gt;...&lt;/gibddreply&gt;
			&lt;fixed&gt;...&lt;/fixed&gt;
		&lt;/small&gt;
	&lt;/pictures&gt;
	&lt;gibddrequests&gt; - запросы в ГИБДД<br>		&lt;request id=&quot;6&quot; gibdd_id=&quot;75&quot; date=&quot;1326669064&quot; user_id=&quot;2&quot; user_name=&quot;Иванов Иван&quot;&gt; - ID запроса, ID ГИБДД, время отправки и имя пользователя<br>			&lt;answer id=&quot;2&quot; date=&quot;1326729513&quot;&gt; - Ответ из ГИБДД и его время<br>				&lt;files&gt;<br>					&lt;file id=&quot;7&quot; type=&quot;image&quot;&gt;src&lt;/file&gt; - Один из загруженых файлов, допустимые типы &quot;image&quot;, &quot;application/pdf&quot; и &quot;text/plain&quot;<br>						...<br>				&lt;/files&gt;<br>			&lt;/answer&gt;<br>		&lt;/request&gt;<br>	&lt;/gibddrequests&gt;
&lt;/hole&gt;</pre>

<h2>Список дефектов</h2>
	<p>Список дефектов получается простым запросом к корню http-сервера методом GET. Могут быть переданы параметры, влияющие на фильтрацию, возможно, упорядочивание и отображение списка дефектов. Например:</p>
	<pre>GET /?filter_rf_subject_id=77&filter_type=holeonroad&filter_status=fixed</pre>
	<p>Приведённый запрос отфильтрует выведет дефекты, расположенные в регионе 77, типа «яма на дороге» и в статусе «починенные». Просто запрос «GET / » выведет все ямы. Список дефектов можно получать без авторизации.</p>
	<p>Возможные параметры, которые могут быть переданы в запросе:</p>
	<table cellspacing="0">
		<tr>
			<td>filter_rf_subject_id</td>
			<td>
				Идентификатор субъекта РФ, к которому относится дефект. Нумерация субъектов не совпадает с нумерацией регионов ГИБДД а совпадает, скорее, с порядком, в котором перечислены субъекты РФ в статье Википедии про субъекты РФ. Пронумерованный список субъектов можно получить с сервера, отправив ему запрос GetRegions (об этом ниже). Если передать номер несуществующего региона, то дефекты выбраны не будут, результат запроса будет пустым. Однако, если передать ноль или какую-нибудь белиберду, которая превратится в ноль после приведения типов, то будут выбраны дефекты, у которых не определён субъект РФ (такие на самом деле имеются, они возникают из-за сбоев при геокодировании, но их мало).<br/>
				Соответствует имени поля ADR_SUBJECTRF.
			</td>
		</tr>
		<tr>
			<td>filter_city</td>
			<td>
				Фильтр по названию города (или по его началу). Если указать, например, «Волг», то будут выбраны ямы, расположенные в Волгограде, Волгодонске и во прочих всех городах, название которых начинается на «Волг».<br/>
				Соответствует имени поля ADR_CITY.<br/>
				Если соответствующий фильтр задан, но равен пустой строке, то будут выбраны дефекты, не привязанные к городам (неправильный формат строки адреса или по иной причине).
			</td>
		</tr>
		<tr>
			<td>filter_status</td>
			<td>
				Фильтр по статусам дефектов. Может принимать значения:
				<ul>
					<li>fresh — свежий дефект, только добавлен на сайт;</li>
					<li>inprogress — в процессе, заявление в ГИБДД;</li>
					<li>fixed — отремонтирован;</li>
					<li>achtung — просрочен (прошло более 37 дней с момента подачи заявления в ГИБДД, никакого результата не видно);</li>
					<li>prosecutor — отправлена жалоба в прокуратуру на бездействие органов ГИБДД;</li>
					<li>gibddre — получен ответ из ГИБДД, но дефект не отремонтирован.</li>
				</ul>
				Если передать несуществующий статус, то дефекты выбраны не будут.<br/>
				Соответствует имени поля STATE.
			</td>
		</tr>
		<tr>
			<td>filter_type</td>
			<td>
				Фильтр по типу дефектов. Спектр типов дефектов довольно обширен, часть типов не используется на сайте, хотя предусмотрены:
				<ul>
					<li>badroad — разбитая дорога;</li>
					<li>holeonroad — яма на дороге;</li>
					<li>hatch — люк;</li>
					<li>crossing — переезд (не используется);</li>
					<li>nomarking — отсутствие разметки (не используется);</li>
					<li>rails — рельсы;</li>
					<li>policeman — лежачий полицейский (не используется);</li>
					<li>fence — ограждение (не используется);</li>
					<li>holeinyard — яма во дворе;</li>
					<li>light — неисправный светофор (не используется);</li>
					<li>snow — снег.</li>
				</ul>
				Если передать несуществуюший тип, то дефекты выбраны не будут.<br/>
				Соответствует имени поля TYPE.
			</td>
		</tr>
		<tr>
			<td>limit</td>
			<td>Количество возвращаемых дефектов. Если не указано, то берётся по умолчанию, 30 штук. На всякий случай максимальный лимит ограничен 2000 дефектами, чтоб злоумышленники не принялись выбирать дефекты десятками тысяч, положив БД и забив канал.</td>
		</tr>
		<tr>
			<td>offset</td>
			<td>Если надо выбрать некоторое количество дефектов не с первого, то можно использовать offset — количество дефектов между первым по порядку и первым возвращённым в выборке. Если не указано, то считается равным 0.</td>
		</tr>
		<tr>
			<td>page</td>
			<td>
				Этот параметр обладает более высоким приоритетом по сравнению с limit и offset, если указать его, то limit и offset будут проигнорированы. Смысл его в том, что он переопределяет эти параметры следующим образом:<br/>
				<pre>limit = default_limit (30 дефектов),
offset = page*default_limit.</pre>
				То есть нумерация страниц начинается с ноля.
			</td>
		</tr>
		<tr>
			<td>order</td>
			<td>Задумано как изменение порядка дефектов в возвращаемом списке, но пока не реализовано и игнорируется.</td>
		</tr>
		<tr>
			<td>html</td>
			<td>Если этот параметр присутствует, то вместо XML возвратится HTML — вёрстка списка дефектов, рассчитанная на маленький (смартфонный) экран. Но пока что не реализовано и игнорируется.</td>
		</tr>
	</table>
	<p>Формат возвращаемого в ответе XML.</p>
	<p>Основная информация содержится в элементе &lt;defectslist&gt; в теле ответа. Там перечислены элементы &lt;hole&gt; - дефекты, полученные в этой выборке. Формат каждого элемента &lt;hole&gt; описан выше. Тело ответа, помимо присутствующих всегда элементов, содержит некоторые дополнительные:</p>
	<pre>&lt;st1234reply&gt;
	...
	&lt;sort&gt; - тут описана сортировка выбоки. В каждом элементе &lt;item&gt;, которых может быть любое количество, но обычно только один, указано направление сортировки, а в свойстве code — имя поля, по которому идёт сортировка.
		&lt;item code="ID"&gt;desc&lt;/item&gt;
		...
	&lt;/sort&gt;
	&lt;filter&gt; - тут описана фильтрация. При применении фильтров (см. таблицу выше) здесь содержатся элементы &lt;item&gt;, значение которых — значение фильтра, а свойство code — имя поля, по которому производится фильтрация, которое не совпадает с названием фильтра (опять же см. таблицу выше).
		&lt;item code="ADR_CITY"&gt;Москва&lt;/item&gt;
		...
	&lt;/filter&gt;
	&lt;navigation&gt; - параметры выборки из БД, limit и offset.
		&lt;item code="limit"&gt;30&lt;/item&gt;
		&lt;item code="offset"&gt;0&lt;/item&gt;
	&lt;/navigation&gt;
	&lt;defectslist&gt;
		&lt;hole ...&gt;...&lt;/hole&gt;
		&lt;hole ...&gt;...&lt;/hole&gt;
		&lt;hole ...&gt;...&lt;/hole&gt;
		…
	&lt;/defectslist&gt;</pre>
	
	<h2>Карточка дефекта</h2>
	<p>Карточка дефекта является общедоступной информацией, для просмотра не требуется авторизация. Чтоб получить XML с карточкой дефекта, надо отправить запрос методом GET на адрес вида /&lt;id дефекта&gt;, например: GET /123 — получить дефект с номером 123 (GET /123/ - тоже, слэш на конце не влияет на номер).</p>
	<p>Если такой дефект существует, то он будет возвращён в XML в теле ответа в описанном выше формате. В том случае, если он существует, но не прошёл премодерацию, будет возвращена ошибка NOT_FOUND.</p>

	<h2>Запрос GetRegions</h2>
	<p>Служебный запрос GetRegions возвращает список регионов, про которые знает РосЯма, с их названиями и внутренней нумерацией. Так как эта нумерация по понятной причине не совпадает с ГИБДД-шной, то этот запрос будет полезен для того, чтоб посмотреть, какой номер у такого-то региона или какой регион с таким-то номером. Под «регионом» понимается полноценный субъект РФ. Запрос GetRegions не имеет никаких параметров фильтрации. Отправил запрос — получил список регионов, всё. Авторизация тоже не нужна для этого.</p>
	<p>Запрос:</p>
	<pre>GET /getregions</pre>
	<p>Формат тела ответа:</p>
	<pre>&lt;regionslist&gt;
	&lt;region id=" номер региона "&gt;полное название&lt;/region&gt;
	...
&lt;/regionslist&gt;</pre>
	<p>Пример ответа:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;st1234reply&gt;
	&lt;requesttime&gt;1307688681&lt;/requesttime&gt;
	&lt;requestmethod&gt;GET&lt;/requestmethod&gt;
	&lt;replytime&gt;1307688681&lt;/replytime&gt;
	&lt;regionslist&gt;
		&lt;region id="1"&gt;Республика Адыгея&lt;/region&gt;
		&lt;region id="2"&gt;Республика Алтай&lt;/region&gt;
		&lt;region id="3"&gt;Республика Башкортостан&lt;/region&gt;
		&lt;region id="4"&gt;Республика Бурятия&lt;/region&gt;
		&lt;region id="5"&gt;Республика Дагестан&lt;/region&gt;
		&lt;region id="6"&gt;Республика Ингушетия&lt;/region&gt;
		&lt;region id="7"&gt;Кабардино-Балкарская республика&lt;/region&gt;
		…
	&lt;/regionslist&gt;
&lt;/st1234reply&gt;</pre>
	
	<h2>Авторизация</h2>
	<p>Авторизация осуществляется отправкой методом POST полей login и password по адресу authorize:</p>
	<pre>POST /authorize/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	password: &lt;пароль пользователя&gt;
}</pre>
	<p>В случае, если логин и/или пароль неправильные, возвращается ошибка с кодом WRONG_CREDENTIALS. Если авторизация прошла успешно, будет возвращён набор данных порльзователя — его ID, ФИО и, самое главное, авторизационный хэш, который привязан к пользователю и который потом надо будет передавать серверу для подтверждения авторизованности пользователя при совершении действий, эту авторизованность требующих.</p>
	<p>Пример ответа об успешной авторизации:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;st1234reply&gt;
	&lt;requesttime&gt;1308213745&lt;/requesttime&gt;
	&lt;requestmethod&gt;POST&lt;/requestmethod&gt;
	&lt;replytime&gt;1308213746&lt;/replytime&gt;
	&lt;user id="1"&gt;
		&lt;username full="1 3 2"&gt;
			&lt;name&gt;1&lt;/name&gt;
			&lt;secondname&gt;2&lt;/secondname&gt;
			&lt;lastname&gt;3&lt;/lastname&gt;
		&lt;/username&gt;
		&lt;passwordhash&gt;&6thg^dsflo8&lt;f6ewt3h4f384bdrtg5g3efev43&lt;/passwordhash&gt;
	&lt;/user&gt;
&lt;/st1234reply&gt;</pre>
	<p>Авторизация через OpenID/OAuth не реализована в данный момент. Кроме того, необходимо иметь в виду, что сессия ведётся средствами Битрикса, на котором работает весь сайт РосЯма, и поэтому обладает всеми сопутствующими достоинствами и недостатками. Кроме того, необходимо помнить о том, что символы &lt; и &gt;, которые могут попасться в хэше, заменены HTML-последовательностями &lt; и &gt; соответственно. Сессия хранится долго, то есть не слетает через некоторое время бездействия, однако, нельзя гарантировать то, что она будет храниться вечно. Если приложение не хранит у себя пароль пользователя, а хранит только возвращаемый при авторизации хэш, то, для заблаговременного сообщения пользователю о том, что его сессия истекла и ему необходимо ввести пароль снова, можно воспользоваться запросом CheckAuth. Он ничего не делает, только проверяет, может ли пользователь авторизоваться по указанному логину и хэшу пароля. Ну и продлевает сессию, наверное, тоже.</p>

	<h2>Запрос CheckAuth</h2>
	<p>Осуществляется отправкой запроса методом POST по адресу /checkauth/:</p>
	<pre>POST /checkauth/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Ответ сервера стандарный, в теле ответа присутствует всего один элемент &lt;checkauthresult&gt;, который содержит строку либо «ok», либо «fail», и имеет свойство result, равное 1 или 0 соответственно.</p>

	<h2>Запрос exit</h2>
	<p>На всякий случай, мало ли, вдруг понадобится, сделана и возможность разлогинится. Запрос exit посылается методом POST или GET по адресу exit:</p>
	<pre>POST /exit/
GET /exit/</pre>
	<p>Никаких параметров более передавать не нужно. Тело ответа всегда будет сообщать об успешном завершении процедуры. Выглядит это так:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;st1234reply&gt;
	&lt;requesttime&gt;1308220587&lt;/requesttime&gt;
	&lt;requestmethod&gt;GET&lt;/requestmethod&gt;
	&lt;replytime&gt;1308220588&lt;/replytime&gt;
	&lt;callresult result="1"&gt;ok&lt;/callresult&gt;
&lt;/st1234reply&gt;</pre>
	
	<h2>Список дефектов, выложенных на сайт пользователем</h2>
	<p>Список дефектов, которые выложил на сайт определённый пользователь получается запросом методом POST по адресу /my/:</p>
	<pre>POST /my/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля, полученный при авторизации&gt;
}</pre>
	<p>Вместо поля passwordhash может быть передан собственно пароль в поле password (тогда поле passwordhash должно отсутствовать вообще, а не быть нулевой длины). В том случае, если логин и хэш пароля (пароль) принадлежат одному пользователю, то в ответе содержится список дефектов, выложенных на сайт этим пользователем, в том числе и те, которые ещё не прошли премодерацию. В противном случае ответ будет содержать ошибку AUTHORIZATION_REQUIRED.</p>
	<p>К списку собственных дефектов может быть применён фильтр, аналогичный фильтру обычного списка дефектов, и выглядит он точно так же.</p>

	<h2>Просмотр карточки дефекта с правами пользователя</h2>
	<p>Авторизованный пользователь может смотреть информацию по каждому из загруженных им дефектов, даже по тем, которые ещё не прошли премодерацию. Для этого надо отправить запрос методом POST по адресу /my/xxx/, где xxx — номер дефекта, который пользователь хочет посмотреть. Например:</p>
	<pre>POST /my/154/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля, полученный при авторизации&gt;
}</pre>
	<p>Вместо поля passwordhash может быть передан собственно пароль в поле password (тогда поле passwordhash должно отсутствовать вообще, а не быть нулевой длины). В том случае, если логин и хэш пароля (пароль) принадлежат пользователю, загрузившему на сайт указанный дефект (в примере — дефект №154), то будет возвращено описание запрошенного дефекта. Если логин и хэш пароля (пароль) не принадлежат одному пользователю, будет возвращена ошибка AUTHORIZATION_REQUIRED, а если дефект принадлежит другому пользователю, то будет возвращена ошибка NOT_FOUND.</p>

	<h2>Добавление дефекта</h2>
	<p>Добавление дефекта осуществляется отправкой необходимых данных методом POST по адресу /add/.</p>
	<pre>POST /add/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	address: &lt;адрес ямы, желательно в формате xAL&gt;
	latitude: &lt;широта дефекта&gt;
	longitude: &lt;долгота дефекта&gt;
	comment: &lt;комментарий пользователя к дефекту&gt;
	type: &lt;тип дефекта&gt;
}</pre>
	<p>Кроме того, должен быть передан хотя бы один графический файл с фотографией ямы.</p>
	<p>Комментарии к передаваемым полям POST:</p>
	<table cellspacing="0">
		<tr>
			<td>passwordhash</td>
			<td>Содержит хэш пароля. Вместо этого поля можно передать пароль в поле password, но тогда поле passwordhash должно отсутствовать (а не быть равным пустой строке).</td>
		</tr>
		<tr>
			<td>login</td>
			<td>Логин пользователя. В том случае, если логин и пароль (хэш пароля) не соответствуют одному пользователю, будет возвращена ошибка AUTHORIZATION_REQUIRED.</td>
		</tr>
		<tr>
			<td>address</td>
			<td>
				Адрес должен быть в формате xAL, или, по крайней мере, начинаться как адрес в этом формате. Определение текстового поля «название города» и числового «идентификатор субъекта РФ» происходит именно на основании данных адреса. Поэтому хорошей практикой может считаться определение адреса по координатам с помощью обратного геокодирования, и позволение пользователю дописать что-то в конец адреса, или слегка отредактировать первую часть адреса, но тогда не исключена такая ситуация, что дефект, территориально расположенный в городе N, будет не находиться в этом городе при поиске по названию города N. Адрес является обязательным параметром, при его отсутствии будет возвращена ошибка NO_ADDRESS.<br/>
				В случае, если по адресу не удалось определить субъект РФ, в XML будет отдельное поле с предупреждением:
				<pre>&lt;warning code="CANNOT_REALISE_SUBJECTRF"&gt;Не удалось опередить субъект РФ&lt;/warning&gt;</pre>
				А если не удалось опередить город, то аналогичное предупреждение CANNOT_REALISE_CITY.
			</td>
		</tr>
		<tr>
			<td>latitude, longitude</td>
			<td>Широта и долгота месторасположения дефекта. Их можно не передавать по отдельности, а передать сразу в поле coordinates перечисленными через запятую, сначала широта, потом долгота. Либо передать их в поле coordinatesr через запятую, но сначала долгота, а потом широта. Координаты должны быть переданы, это обязательные параметры. В том случае, если они не будут переданы, будут возвращены ошибки LATITUDE_NOT_SET или LONGITUDE_NOT_SET.</td>
		</tr>
		<tr>
			<td>comment</td>
			<td>Текстовый комментарий к дефекту, может быть пустым.</td>
		</tr>
		<tr>
			<td>type</td>
			<td>Тип дефекта, один из возможных. При указании несуществующего типа будет возвращена ошибка INCORRECT_TYPE, при указании существующего, но неиспользуемого типа дефектов будет возвращена ошибка DEPRECATED_TYPE.</td>
		</tr>
	</table>
	<p>Комментарии к файлам.</p>
	<p>Файлы должны быть переданы именно как файлы (encryption type должно быть «multipart/form-data»). Имена, под которыми файлы передаются на сервер, не имеют значения, но их должно быть не больше десяти. Обрабатываться они будут в том порядке, в котором будут переданы на сервер. В том случае, если файлов будет больше, чем десять, те файлы, которые были переданы после десятого, не будут обработаны, и будет выдано предупреждение FILES_DROPPED.</p>
	<p>В том случае, если суммарный размер файлов превышает допустимые ограничения, никакой специфической ошибки не возвращается, так как веб-сервер обычно обрабатывает эту ситуацию самостоятельно. Вероятнее всего в этом случае можно получить ошибку AUTHORIZATION_REQUIRED. Узнать максимальный размер одного файла и максимальный суммарный размер файлов можно с помощью запроса GetFileUploadLimits.</p>
	<p>В случае, если при загрузке файлов произошли какие-то другие ошибки, то они будут выведены в XML.</p>
	<p>Ошибки, которые могут возникнуть при загрузке файлов:</p>
	<table cellspacing="0">
		<tr>
			<td>NO_FILES</td>
			<td>Ни одного файла не загружено</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>Слишком большой файл</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>Слишком много файлов (количество превышает директиву max_file_uploads в php.ini) — но эту ошибку вряд ли можно наблюдать, если честно</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>Файл загружен только частично</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>
				Невозможно загрузить файл.<br/>
				Это сообщение выдаётся в случае, если загрузить файлы не удалось по какой-то внутренней причине, о которой пользователю знать не обязательно — проблемы с записью на диск, с правами доступа и так далее.</td>
			</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>
				Неподдерживаемый формат файла.<br/>
				В качестве изображений принимаются картинки форматов JPEG, PNG и GIF, попытка загрузить файл любого другого формата вызовет эту ошибку.</td>
			</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>
				Неизвестный формат изображения.<br/>
				Если mime-type и содержимое картинки не совпадают или что-то случилось на сервере, что не позволяет открыть этот файл для пережатия в меньший размер, то будет показана эта ошибка.
			</td>
		</tr>
	</table>
	<p>В том случае, если по какой-то причине не удалось добавить дефект, то будет возвращена ошибка CANNOT_ADD_DEFECT, в которой будет описание, почему, собственно, не удалось добавить дефект, и элемент callresult с результатом 0 (fail). В том случае, если дефект добавить удалось, будет возвращён его идентификатор в элементе XML-репорте об успешном завершении операции:</p>
	<pre>&lt;callresult result="1" inserteddefectid="32"&gt;ok&lt;/callresult&gt;</pre>
	<p>В свойстве inserteddefectid элемента callresult находится идентификатор добавленного дефекта.</p>

	<h2>Запрос GetFileUploadLimits</h2>
	<p>Запрос позволяет выяснить настройки PHP на сервере и прочие ограничения, присутствующие при загрузке фалов на сервер. Отправляется методом GET по адресу /getfileuploadlimits:</p>
	<pre>GET /getfileuploadlimits</pre>
	<p>Запрос авторизации не требует и возвращает вот такой XML:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;st1234reply&gt; 
	&lt;requesttime&gt;1308920653&lt;/requesttime&gt; 
	&lt;requestmethod&gt;GET&lt;/requestmethod&gt; 
	&lt;replytime&gt;1308920653&lt;/replytime&gt; 
	&lt;maxpostsize&gt;1M&lt;/maxpostsize&gt; 
	&lt;maxfilesize&gt;3M&lt;/maxfilesize&gt; 
	&lt;maxfilescount&gt;10&lt;/maxfilescount&gt; 
&lt;/st1234reply&gt;</pre>
	<p>Элементы &lt;maxpostsize&gt; и &lt;maxfilesize&gt; содержат значения значений post_max_size и upload_max_filesize из php.ini в том виде, в каком они содержатся там; как видно в примере — даже без проверок на адекватность. Элемент maxfilescount содержит максимальное число файлов, которое можно загрузить за один раз.</p>

	<h2>Изменение дефекта</h2>
	<p>Существует несколько запросов, позволяющих изменить дефект. Эти запросы различны по тем данным, которые могут быть изменены, и по тому, когда они могут быть вызваны, это зависит от статуса дефекта. По своей сути эти запросы сводятся к одному универсальному, но снаружи этого не видно.</p>
	<p>Список запросов, которыми можно изменять дефект.</p>
	<table cellspacing="0">
		<tr>
			<th>Запрос</th>
			<th>Статус дефекта, когда может быть вызван запрос</th>
			<th>Поля, которые можно изменять, и прочие допустимые изменения</th>
		</tr>
		<tr>
			<td>update</td>
			<td>новый</td>
			<td>координаты, тип, строка адреса, комментарий, можно загружать ещё файлы и удалять имеющиеся</td>
		</tr>
		<tr>
			<td>set_inprogress</td>
			<td>новый, исправлено</td>
			<td>меняется статус на «в процессе». Для дефекта в статусе «исправлено» этот запрос доступен только в том случае, если не была загружена фотография исправленного дефекта, и статус может измениться на «просрочен» или «получен ответ из гибдд», в зависимости от того, какой был статус до статуса «исправлен»</td>
		</tr>
		<tr>
			<td>revoke</td>
			<td>в процессе</td>
			<td>меняется статус обратно на «новый»</td>
		</tr>
		<tr>
			<td>set_replied</td>
			<td>в процессе, получен ответ, просрочен</td>
			<td>меняется статус на «получен ответ из ГИБДД», необходимо добавить одно или несколько изображений (обычно скан ответа из ГИБДД) и, по желанию, комментарий. Можно удалить ранее загруженный ответ из ГИБДД</td>
		</tr>
		<tr>
			<td>set_fixed</td>
			<td>все, кроме «исправлено»</td>
			<td>меняется статус на «исправлено», можно добавить одно или несколько изображений и комментарий</td>
		</tr>
		<tr>
			<td>to_prosecutor</td>
			<td>просрочен</td>
			<td>статус меняется на «жалоба в прокуратуру подана»</td>
		</tr>
		<tr>
			<td>revoke_p</td>
			<td>жалоба в прокуратуру подана</td>
			<td>статус меняется обратно на «просрочен»</td>
		</tr>
	</table>
	<p>Дефект переходит из статуса «в процессе» в статус «просрочен» самостоятельно с течением времени.</p>
	<p>Для удобства пользования существует служебный запрос GetUpdateMethods, который сообщает список возможных способов изменить дефект, а также — какие поля принимаются при каждом запросе.</p>

	<h2>Вызов GetUpdateMethods</h2>
	<p>Вызов существует в двух вариантах — в общем случае и применительно к дефекту. В общем случае вызывается методом GET адрес /getupdatemethods:</p>
	<pre>GET /getupdatemethods</pre>
	<p>Применительно к одному дефекту он вызывается методом POST по адресу /my/&lt;defect_id&gt;/getupdatemethods:</p>
	<pre>POST /my/&lt;defect_id&gt;/getupdatemethods
Поля POST
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Как и в других случах, тут вместо хэша пароля можно передать собственно пароль в поле password, а поле passwordhash в таком случае должно отсутствовать. В том случае, если логин и пароль не подходят, будет выдана ошибка AUTHORIZATION_REQUIRED. В том счлкчае, если дефект с номером &lt;defect_id&gt; отсутствует или загружен другим пользователем, будет выдана ошибка NOT_FOUND.</p>
	<p>В общем случае тело ответа сервера выглядит следующим образом:</p>
	<pre>&lt;state id="state-id"&gt;
	&lt;method name="method-name"&gt; 
		&lt;field&gt;field_name&lt;/field&gt;
		...
	&lt;/method&gt;
	... 
&lt;/state&gt;
…</pre>
	<p>В теле ответа перечислены элементы state (теоретически, их может и не быть), каждый из которых соответствует статусу дефекта. В случае, если вы запрашиваете этот метод для одного дефекта, то элемент state будет максимум один — соответствующий статусу выбранного дефекта. У элемента state есть свойство id — это код статуса дефекта.</p>
	<p>Внутри элемента state расположены элементы method, каждый из которых соответствует методу обновления дефекта, который может быть вызван для дефекта в текущем статусе. Соответственно, этих элементов тоже может не быть. У элемента method есть свойство name, которое является именем этого метода.</p>
	<p>Внутри элемента method расположены элементы field (их тоже может не быть), каждый из которых соответствует свойству дефекта, который может быть изменён данным методом. И является ключом массива с данными, который передаётся методом POST при обновлении дефекта. Более подробно о кодах field см. в описании метода обновления update.</p>

	<h2>Метод обновления дефекта update</h2>
	<p>Это наиболее полный метод обновления дефекта, с помощью которого данные дефекта можно обновить полностью (за исключением авторства и даты создания, разумеется). Поэтому данный метод применим только к дефектам в статусе «новый».</p>
	<p>Вызывается данный метод отправкой данных методом POST на адрес /my/&lt;defect-id&gt;/update:</p>
	<pre>POST /my/&lt;defect-id&gt;/update
Поля POST (практически идентичны с методом добавления дефекта):
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	address: &lt;адрес ямы, желательно в формате xAL&gt;
	latitude: &lt;широта дефекта&gt;
	longitude: &lt;долгота дефекта&gt;
	comment: &lt;комментарий пользователя к дефекту&gt;
	type: &lt;тип дефекта&gt;
	deletefiles: &lt;удаляемые файлы&gt;
}</pre>
	<p>Кроме того, могут быть переданы графические файлы, который добавятся к дефекту.</p>
	<p>Комментарии к передаваемым полям POST:</p>
	<table cellspacing="0">
		<tr>
			<td>passwordhash</td>
			<td>Содержит хэш пароля. Вместо этого поля можно передать пароль в поле password, но тогда поле passwordhash должно отсутствовать (а не быть равным пустой строке).</td>
		</tr>
		<tr>
			<td>login</td>
			<td>Логин пользователя. В том случае, если логин и пароль (хэш пароля) не соответствуют одному пользователю, будет возвращена ошибка AUTHORIZATION_REQUIRED.</td>
		</tr>
		<tr>
			<td>address</td>
			<td>
				Адрес должен быть в формате xAL, или, по крайней мере, начинаться как адрес в этом формате. Если адрес не передан, то адрес дефекта не изменится. В случае, если по адресу не удалось определить субъект РФ, в XML будет отдельное поле с предупреждением:
				<pre>&lt;warning code="CANNOT_REALISE_SUBJECTRF"&gt;Не удалось опередить субъект РФ&lt;/warning&gt;</pre>
				А если не удалось опередить город, то аналогичное предупреждение CANNOT_REALISE_CITY. Желательно передавать адрес полный, полученный с помощью геокодера. Допускатся передавать адрес частичный, совпадающий с полем address дефекта, но в том случае, если он будет изменён, невозможно гарантировать то, что будет сохранён город и регион дефекта.
			</td>
		</tr>
		<tr>
			<td>latitude, longitude</td>
			<td>
				Широта и долгота месторасположения дефекта. Их можно не передавать по отдельности, а передать сразу в поле coordinates перечисленными через запятую, сначала широта, потом долгота. Либо передать их в поле coordinatesr через запятую, но сначала долгота, а потом широта.<br/>
				Если координаты не переданы, то координаты дефекта не изменятся.
			</td>
		</tr>
		<tr>
			<td>comment</td>
			<td>Текстовый комментарий к дефекту, может быть пустым. Если не передан, то не комментарий к дефекту не изменится.</td>
		</tr>
		<tr>
			<td>type</td>
			<td>Тип дефекта, один из возможных. При указании несуществующего типа будет возвращена ошибка INCORRECT_TYPE, при указании существующего, но неиспользуемого типа дефектов будет возвращена ошибка DEPRECATED_TYPE. Если тип не передан, то тип дефекта не изменится.</td>
		</tr>
		<tr>
			<td>deletefiles</td>
			<td>Массив ID изображений.</td>
		</tr>
	</table>
	<p>Комментарии к загружаемым файлам аналогичны случаю создания дефекта. С помощью многократного редактирования дефекта можно загрузить достаточно большое количество файлов, но их суммарное количество не должно превышать 100, в противном случае будут выведены предупреждения FILES_DROPPED и FILES_LIMIT_REACHED (достигнуто максимальное количество файлов для дефекта).</p></p>
	<p>В том случае, если данный метод неприменим для дефекта из-за того, что последний не в статусе «новый», будет выведена ошибка UNAPPROPRIATE_METHOD (неподходящий метод).
	<p>Если обновление дефекта прошло успешно, то будет выведен элемент &lt;callresult result="1"&gt;ok&lt;/callresult&gt;, в противном случае будет выведен элемент &lt;callresult result="0"&gt;fail&lt;/callresult&gt; и ошибка CANNOT_UPDATE_DEFECT (не удалось обновить дефект) в том случае, если произошёл какой-то сбой иного рода, элемент error будет содержать текст ошибки, например:</p>
	<pre>&lt;error code="CANNOT_UPDATE_DEFECT"&gt;Неподдерживаемый формат изображения&lt;/error&gt;</pre>
	
	<h2>Метод обновления дефекта set_inprogress</h2>
	<p>Метод предназначен, в основном, для перевода дефекта из статуса «новый» в статус «в процессе», однако, может применяться и для отмены статуса «исправлен» в том случае, если ещё не была загружена фотография исправленного дефекта. Вызывается отправкой запроса методом POST на адрес /my/&lt;defect-id&gt;/setinprogress:</p>
	<pre>POST /my/&lt;defect-id&gt;/setinpgogress
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка UNAPPROPRIATE_METHOD. Результат выполнения выводится в элементе &lt;callresult&gt;. Если произошла какая-то иная ошибка, то будет выведена ошибка CANNOT_UPDATE_DEFECT, элемент error будет содержать текст ошибки.</p>

	<h2>Метод обновления дефекта revoke</h2>
	<p>Метод служит для возвращения дефекту, который в статусе «в процессе», статуса «новый». Соответственно, применим только для дефектов в статусе «в процессе». Вызывается отправкой запроса методом POST по адресу /my/&lt;defect-id&gt;/revoke:</p>
	<pre>POST /my/&lt;defect-id&gt;/revoke
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка UNAPPROPRIATE_METHOD. Результат выполнения выводится в элементе &lt;callresult&gt;. Если произошла какая-то иная ошибка, то будет выведена ошибка CANNOT_UPDATE_DEFECT, элемент error будет содержать текст ошибки.</p>

	<h2>Метод обновления дефекта set_replied</h2>
	<p>Данный метод предназначен для перевода дефекта из статуса «в процессе» в статус «получен ответ из ГИБДД» или для добавления ещё сканов ответа из ГИБДД. Применим только к дефектам в статусе «в процессе». Вызывается отправкой запроса методом POST по адресу /my/&lt;defect-id&gt;/setreplied:</p>
	<pre>POST /my/&lt;defect-id&gt;/setreplied
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	comment: &lt;комментарий&gt;
	deletefiles: &lt;список удаляемых файлов ответов ГИБДД через запятую&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password.</p>
	<p>Должен быть передан как минимум один графический файл, являющийся, по замыслу, сканом ответа из ГИБДД. Максимальное число файлов всё так же 10. Комментарий не обязателен.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка UNAPPROPRIATE_METHOD. Результат выполнения выводится в элементе &lt;callresult&gt;. Если произошла какая-то иная ошибка, то будет выведена ошибка CANNOT_UPDATE_DEFECT, элемент error будет содержать текст ошибки. Если не загружено ни одного файла, будет выдана ошибка NO_FILES. Также могут быть выданы ошибки, связанные с загрузкой файлов, аналогичные описанным в разделе о методе обновления update.</p>

	<h2>Метод обновления дефекта set_fixed</h2>
	<p>Данный метод предназначен для перевода дефекта в статус «исправлено». Применим к дефекту в любом статусе, кроме «новый» и «исправлено». Вызывается отправкой запроса методом POST по адресу /my/&lt;defect-id&gt;/setfixed:</p>
	<pre>POST /my/&lt;defect-id&gt;/setfixed
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	comment: &lt;комментарий&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password.</p>
	<p>Комментарий не обязателен. Также могут быть переданы графические файлы, но они тоже не обязательны, и к ним относятся все замечания, касающиеся загрузки файлов, для вышеописанных методов.</p>
	<p>Следует отметить отдельно, что в том случае, если файл не был загружен, то дефект можно вернуть в статус «в процессе» (или «просрочен»), а если был загружен файл, то нельзя.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка UNAPPROPRIATE_METHOD. Результат выполнения выводится в элементе &lt;callresult&gt;. Если произошла какая-то иная ошибка, то будет выведена ошибка CANNOT_UPDATE_DEFECT, элемент error будет содержать текст ошибки. Если не загружено ни одного файла, будет выдана ошибка NO_FILES. Также могут быть выданы ошибки, связанные с загрузкой файлов, аналогичные описанным в разделе о методе обновления update.</p>

	<h2>Метод обновления дефекта to_prosecutor</h2>
	<p>Метод служит для простановки дефекту статуса «заявление отправлено в прокуратуру». Метод применим только для просроченных дефектов (находящихся в статусе «просрочен»). Вызывается отправкой запроса методом POST по адресу /my/&lt;defect-id&gt;/toprosecutor:</p>
	<pre>POST /my/&lt;defect-id&gt;/toprosecutor
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка UNAPPROPRIATE_METHOD. Результат выполнения выводится в элементе &lt;callresult&gt;. Если произошла какая-то иная ошибка, то будет выведена ошибка CANNOT_UPDATE_DEFECT, элемент error будет содержать текст ошибки.</p>

	<h2>Метод обновления дефекта revoke_p</h2>
	<p>Метод служит для простановки дефекту в статуске «заявление в прокуратуре» статуса «просрочен». Вызывается отправкой запроса методом POST по адресу /my/&lt;defect-id&gt;/revokep:</p>
	<pre>POST /my/&lt;defect-id&gt;/revokep
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка UNAPPROPRIATE_METHOD. Результат выполнения выводится в элементе &lt;callresult&gt;. Если произошла какая-то иная ошибка, то будет выведена ошибка CANNOT_UPDATE_DEFECT, элемент error будет содержать текст ошибки.</p>

	<h2>Удаление дефекта</h2>
	<p>Удалить можно только дефект в статусе «новый». Для этого надо отправить запрос методом POST по адресу /my/&lt;defect-id&gt;/delete:</p>
	<pre>POST /my/&lt;defect-id&gt;/delete
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка UNAPPROPRIATE_METHOD. Результат выполнения выводится в элементе &lt;callresult&gt;. Если произошла какая-то иная ошибка, то будет выведена ошибка CANNOT_DELETE_DEFECT, элемент error будет содержать текст ошибки.</p>

	<h2>Геокодирование</h2>
	<p>Прямое геокодирование — определение координат по топониму. Обратное — наоборот. Для уменьшения злоупотребления геокодированием авторизация пользователя является обязательной. Фактически, геокодер РосЯмы является прокси-сервером для геокодера Яндекса, так что можно обращаться напрямую в Яндекс, и ответ сервера практически совпадает с ответом Яндекса: <a href="http://api.yandex.ru/maps/geocoder/doc/desc/concepts/About.xml">api.yandex.ru/maps/geocoder/doc/desc/concepts/About.xml</a></p>
	<p>Геокодирование получается обращением методом POST по адресу /geocode/:</p>
	<pre>POST /geocode/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	geocode: &lt;любая строка или координаты через запятую&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password. Обратите внимание, что в поле geocode передаётся сначала долгота, потом широта.</p>
	<p>Ответ сервера содержит в себе элемент &lt;geocode&gt;, в котором целиком содержится 	(за исключением тэга &lt;?xml&gt;) ответ Яндекса в формате XML (пробелы, которыми сделан отступ строк слева, заменены на символы табуляции). В случае ошибки элемент &lt;geocode&gt; отсутствует, а вместо него выводится ошибка. Если не указан адрес или координаты, то выводится ошибка GEOCODE_EMPTY_REQUEST (пустой запрос к геокодеру), в случае каких-либо иных ошибок выводится GEOCODE_ERROR.</p>

	<h2>Получение ФИО начальника ГИБДД региона</h2>
	<p>Для того, чтоб узнать ФИО начальника УГИБДД региона, в котором расположен дефект, необходимо воспользоваться запросом getgibddhead. Запрос выполняется методом POST по адресу /my/&lt;defect-id&gt;/getgibddhead, и для него необходима авторизация:</p>
	<pre>POST /my/&lt;defect-id&gt;/getgibddhead/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password.</p>
	<p>Ответ сервера содержит элемент &lt;gibddhead&gt;, в котором три элемента - &lt;nominative&gt; и &lt;dative&gt; - соответственно, ФИО начальника УГИБДД соответствующего региона в именительном (nominative) и дательном (dative) падежах. Каждый из этих элементов имеет свойство post, значение которого — пост, занимаемый указанным начальником. Элемент &lt;gibddhead&gt;, помимо этого, имеет свойство subjectid, в котором содержится внутренний ID субъекта РФ. Кроме того, элемент &lt;nominative&gt; имеет свойство gibdd, содержащее наименование управления в именительном падеже.</p>
	<p>Пример тела ответа сервера:</p>
	<pre>&lt;gibddhead subjectid="72"&gt; 
	&lt;nominative post="Начальник УПРАВЛЕНИЯ ГИБДД УВД СМОЛЕНСКОЙ ОБЛАСТИ" gibdd="УПРАВЛЕНИЕ ГИБДД УВД СМОЛЕНСКОЙ ОБЛАСТИ"&gt;Ивченков Владимир Владимирович&lt;/nominative&gt; 
	&lt;dative post="Начальнику УПРАВЛЕНИЯ ГИБДД УВД СМОЛЕНСКОЙ ОБЛАСТИ"&gt;Ивченкову Владимиру Владимировичу&lt;/dative&gt; 
&lt;/gibddhead&gt;</pre>
	<p>Если дефекта не существует или он принадлежит другому пользователю, будет выведена ошибка NOT_FOUND. В случае, если что-то пошло не так, будет выведена ошибка INTERNAL (внутренняя ошибка). Если дефект не привязан к региону, то ошибки не будет, а все эти значения будут пустыми, но будет дополнительно выведено предупреждение NO_SUBJECTRF_ID (дефект не привязан к субъекту РФ).</p>
	<p>Несколько замечаний. Список началников ГИБДД по регионам с периодом примерно раз в неделю автоматически обновляется с сайта gibdd.ru. Если на сайте gibdd.ru поменяется вёрстка, то, разумеется, обновление поломается. Переделывание именительного падежа в родительный происходит через API склонятора Яндекса <a href="http://nano.yandex.ru/project/inflect/">nano.yandex.ru/project/inflect</a>.</p>

<a name="getgibddheadbyregion"></a>
<h2>Получение ФИО начальника, адреса и телефона ГИБДД по ID региона</h2> 
 
<p>Для того, чтоб узнать ФИО начальника, адрес и телефон УГИБДД региона, необходимо воспользоваться запросом getgibddheadbyregion. Запрос выполняется методом GET или POST по адресу /getgibddheadbyregion :</p>
 
<pre>GET/POST /getgibddheadbyregion <br />Поля GET/POST:
{
	region_id: &lt;ID региона&gt;<br />}</pre> 
 
<p>Ответ сервера содержит элемент &lt;gibdd&gt;, в котором три элемента - &lt;gibdditem&gt;, &lt;nominative&gt; и &lt;dative&gt; - соответственно, полное название УГИБДД региона с адресом и телефоном, ФИО начальника УГИБДД соответствующего региона в именительном (nominative) и дательном (dative) падежах. Каждый из двух последних элементов имеет свойство post, значение которого — пост, занимаемый указанным начальником. Элемент &lt;gibdd&gt;, помимо этого, имеет свойство subjectid, в котором содержится внутренний ID субъекта РФ. Кроме того, элемент &lt;nominative&gt; имеет свойство gibdd, содержащее наименование управления в именительном падеже.</p>

<p>Пример тела ответа сервера:</p>
<pre>&lt;gibdd subjectid=&quot;49&quot;&gt;
	&lt;gibdditem address=&quot;197376, г. Санкт-Петербург, ул. Профессора Попова, 42&quot; tel=&quot;(812) 234-90-21, (812) 234-26-46&quot;&gt;Управление ГИБДД ГУ МВД России по г. Санкт-Петербургу и Ленинградской области&lt;/gibdditem&gt;
	&lt;nominative post=&quot;Начальник&quot; gibdd=&quot;Управление ГИБДД ГУ МВД России по г. Санкт-Петербургу и Ленинградской области&quot;&gt;Бугров Сергей Иванович&lt;/nominative&gt;
	&lt;dative post=&quot;Начальнику Управление ГИБДД ГУ МВД России по г. Санкт-Петербургу и Ленинградской области&quot;/&gt;
&lt;/gibdd&gt;</pre>
<p>Если региона не существует или он не указан, будет выведена ошибка NOT_FOUND. В случае, если что-то пошло не так, будет выведена ошибка INTERNAL (внутренняя ошибка). </p>
<p>Несколько замечаний. Список началников ГИБДД по регионам с периодом примерно раз в неделю автоматически обновляется с сайта gibdd.ru. Если на сайте gibdd.ru поменяется вёрстка, то, разумеется, обновление поломается. Переделывание именительного падежа в родительный происходит через API склонятора Яндекса <a href="http://nano.yandex.ru/project/inflect/" >nano.yandex.ru/project/inflect</a>.</p>

	
	<h2>Получение с сервера PDF</h2>
	<p>В некоторых ситуациях вместо ответа в формате XML сервер может предложить для скачивания PDF-файл со сформированным заявлением в прокуратуру или жалобой в ГИБДД. Для получения с сервера PDF необходимо отправить запрос методом POST по определённому адресу и передать заполненные поля, которые подставятся в текст.</p>


	<h2>Формирование и получение с сервера жалобы в ГИБДД</h2>
	<p>Для получения с сервера жалобы в ГИБДД в формате PDF необходимо отправить на сервер запрос методом POST по адресу /my/&lt;defect-id&gt;/pdf_gibdd/:</p>
	<pre>POST /my/&lt;defect-id&gt;/pdf_gibdd/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	to: &lt;кому&gt;
	from: &lt;от кого&gt;
	postaddress: &lt;почтовый адрес отправителя&gt;
	holeaddress: &lt;адрес дефекта&gt;
	signature: &lt;подпись (фамилия и инициалы отправителя)&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password.</p>
	<p>В поле from должно быть указано полное имя отправителя. Так как на сайте в профиле может быть не указано полное правильное имя пользователя, имеется возможность указать его отдельно. В поле to должно быть написана должность и полное имя сотрудника ГИБДД, которому адресуется жалоба. Должность и полное имя сразу в дательном падеже начальника управления ГИБДД соответствующего субъекта РФ можно получить с помощью запроса  getgibddhead. Так как ответы из ГИБДД будут приходить в письменной форме почтой, необходимо указать свой почтовый адрес. На сайте не хранятся почтовые адреса пользователей. Адрес дефекта нужно указать чётко, чтоб было понятно в ГИБДД.</p>
	<p>Данный запрос применим только к дефектам, находящимся в статусах «новый» и «в процессе». В случае, если дефект находится не в этих статусах, будет выведена ошибка UNAPPROPRIATE_METHOD. Скрипты на сайте не проверяют валидность вводимых данных. Сгенерированный PDF-файл не хранится на сервере.</p>

	<h2>Формирование и получение с сервера заявления в прокуратуру</h2>
	<p>Для получения с сервера жалобы в ГИБДД в формате PDF необходимо отправить на сервер запрос методом POST по адресу /my/&lt;defect-id&gt;/pdf_prosecutor/:</p>
	<pre>POST /my/&lt;defect-id&gt;/pdf_prosecutor/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	from: &lt;от кого&gt;
	postaddress: &lt;почтовый адрес отправителя&gt;
	holeaddress: &lt;адрес дефекта&gt;
	signature: &lt;подпись (фамилия и инициалы отправителя)&gt;
	gibdd: &lt;название отделения ГИБДД&gt;
	gibddre: &lt;ответ ГИБДД&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password. В поле from должно быть указано полное имя отправителя. Так как на сайте в профиле может быть не указано полное правильное имя пользователя, имеется возможность указать его отдельно. В поле postaddress необходимо указать свой полный почтовый адрес. На сайте не хранятся почтовые адреса пользователей. Адрес дефекта нужно указать чётко, чтоб было понятно в прокуратуре. Поле gibdd должно содержать название отделения ГИБДД, куда было направлено заявление. Для его получения можно воспользоваться запросом getgibddhead. Поле gibddre должно содержать содержательную часть ответа из ГИБДД и используется только в том случае, если этот ответ получен. Отправить заявление в прокуратуру можно, когда дефект находится в двух статусах: «просрочен» и «получен ответ из ГИБДД», в обоих случаях текст заявление будет разный, в первом случае — жалоба на бездействие ГИБДД, во втором — заявление о нарушении закнодательства о содержании и ремонте дорог и безопасности дорожного движения. В том случае, если дефект находится в другом статусе, будет выведена ошибка UNAPPROPRIATE_METHOD. Скрипты на сайте не проверяют валидность вводимых данных. Сгенерированный PDF-файл не хранится на сервере.</p>
</body>
</html>
